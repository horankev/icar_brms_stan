---
title: "Bayesian ICAR"
output: 
 md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE)
```

## Global vs local smoothing parameters in ICAR

Using `brms` and `stan` to go beyond the global standard deviation parameter of `mgcv` in intrinsic conditional autocorrelation spatial structures.

```{r, echo = FALSE}

## Packages

# install.packages("devtools")
# devtools::install_github("m-clark/gammit")

# required packages
packages <- c(
  "tidyverse", # family of packages
  "sf", # for managing spatial data
  "here", # file management
  "spdep", # areal data
  "kableExtra", # making tables
  "cartogram", # making cartograms
  "parlitools", # data source
  "mgcv", # for GAMs
  "ggforce", # for geom_circle function
  "ggpubr", # arranging multiple plots
  "patchwork",# arranging multiple plots
  "ggsflabel", # has repel labels for sf
  "ggnewscale", # for multiple scales in one ggplot
  "broom", # make tidy tibbles from model objects
  "latex2exp", # for latex in ggplot subtitles
  "PieGlyph", # making swingometers
  "broom.mixed", # extract tidy output
  "merTools", # with plot functions
  "gammit", # for pulling out random and fixed effects
  "brms",
  "geostan", # extracts number of edges and indexes them
  "rstan"
  )


# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE, quietly = TRUE))

# to over-ride conflict with `MASS` package
select <- dplyr::select

# make the labels contrast inversely with fill colour
contrast <- function(colour) {
  out   <- rep("black", length(colour))
  light <- farver::get_channel(colour, "l", space = "hcl")
  out[light < 50] <- "white"
  out
}
autocontrast <- aes(colour = after_scale(contrast(fill)))

# install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

```

```{r, echo = FALSE}

## Data preparation

# prepare the data
# extract and join census and election data from parlitools package
census_11 <- parlitools::census_11 |> 
  select(-constituency_name,-constituency_type,-pano, -region, -country)
bes_2019 <- parlitools::bes_2019

elect_results <- left_join(bes_2019,census_11, by=c("ons_const_id"))

# get constituency and higher level geometry data
uk_map_download <- st_read(
  "https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/WPC_Dec_2019_UGCB_UK_2022/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson",
  quiet = TRUE)

# only need the boundaries and the IDs for merging with parlitools data
uk<- uk_map_download |> 
  select(pcon19cd,geometry) |> 
  st_transform(crs=27700) |> 
  st_make_valid() # ensure valid line overlaps etc

# create dataframe for filtering-out speaker constituencies below
speakers <- data.frame(
  year = c(2017,2019),
  constituency_name = c("Buckingham","Chorley")
)

# join constituency polygons to parlitools data
# filter out Scotland and Northern Ireland
# filter out the speakers' constituencies
# calculate the desired explanatory variables
# make levels into factors for use with `mgcv`

df <- elect_results |> 
  left_join(uk, by=c("ons_const_id"="pcon19cd")) |> 
  filter(!country %in% c("Scotland","Northern Ireland")) |> 
  filter(!constituency_name %in% speakers$constituency_name) |>
  mutate(degree_educated = qual_level_4,
         health_not_good = health_fair + health_bad + health_very_bad,
         white = ethnicity_white,
         con_change = con_19 - con_17, # difference in %
         lab_change = lab_19 - lab_17,
         con_swing = (con_change - lab_change)/2, # Butler swing
         region = factor(ifelse(county == "Merseyside", "Merseyside", region)),
         county = factor(county),
         constituency_name = factor(constituency_name)) |> 
  st_as_sf()

speaker_sf <- elect_results |> 
  left_join(uk, by=c("ons_const_id"="pcon19cd")) |> 
  filter(!country %in% c("Scotland","Northern Ireland")) |> 
  filter(constituency_name %in% speakers$constituency_name) |> 
  st_as_sf()

```

```{r, echo = FALSE}

# create region boundaries layer for mapping
regions <- df |> group_by(region) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

# create county boundaries layer for mapping
counties <- df |> group_by(county) |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

# create outline layer for mapping
uk_outline <- df |> 
  summarise() |> 
  st_as_sf() |> 
  st_transform(crs=27700)

# filter out required independent variables and scale them
# then add back to the features which were not scaled
df_scaled <- df |> 
  st_drop_geometry() |> 
  select(degree_educated,
    health_not_good,
    white) |> 
  scale() |> 
  as.data.frame() |> 
  mutate(con_swing = df$con_swing,
         population = df$population,
         region = factor(df$region),
         county = factor(df$county),
         constituency_name = factor(df$constituency_name))

# create a simple features (spatial) version of this with a geometry column
df_scaled_sf <- df_scaled |> 
  mutate(geometry = df$geometry) |> 
  st_as_sf() |> 
  st_transform(crs=27700)

```

```{r, eval=FALSE, echo=FALSE}

# create cartograms sized by population
# by constituency

df_temp <- elect_results |> 
  left_join(uk, by=c("ons_const_id"="pcon19cd")) |> 
  filter(!country %in% c("Scotland","Northern Ireland")) |> 
  mutate(region = factor(ifelse(county == "Merseyside", "Merseyside", region))) |> 
  st_as_sf()

# construct the contiguities with the speaker's seats still present, then remove them
const_contig_full <- cartogram_cont(df_temp |> st_simplify(),weight="population",itermax = 5) |> 
  st_simplify()

# write_rds(const_contig_full, "/Users/kevinhoran/Documents/swing_project/elsevier_asap_revised/const_contig_full.rds")

```

```{r, echo = FALSE}

const_contig_full <- read_rds("/Users/kevinhoran/Documents/swing_project/elsevier_asap_revised/const_contig_full.rds")

speaker_carto <- const_contig_full |> 
  filter(constituency_name %in% speakers$constituency_name)

const_contig <- const_contig_full |> 
  filter(!constituency_name %in% speakers$constituency_name) |> 
  mutate(degree_educated = df$degree_educated,
         health_not_good = df$health_not_good,
         white = df$white,
         con_swing = df$con_swing)

# by region
carto_region <- const_contig_full |> 
  group_by(region) |> 
  summarise()

# by county
carto_county <- const_contig_full |> 
  group_by(county) |> 
  summarise()

# an outline map
carto_outline <- const_contig_full |> 
  summarise()

```

```{r, echo = FALSE}

### Contiguities

# Create contiguity matrix of constituencies, with some manual alterations to account for islands, bridges, ferries and tunnels.

# make a list of contiguities
nlistconst <- df %>% st_touches()

# make it a named list (required for `mgcv`)
names(nlistconst) <- df$constituency_name

# customise it somewhat by fixing islands and inlets etc...

# fix island contiguities (Isle of Wight and Ynys Mon to nearest mainland constituency/ies)
# Portsmouth South is 384
nlistconst[[384]] <- c(202,252,383) |> as.integer()
# Gosport is 202
nlistconst[[202]] <- c(188,252,384) |> as.integer()
# Fareham is 188
nlistconst[[188]] <- c(171,202,252,303,383) |> as.integer()
# New Forest East is 329
nlistconst[[329]] <- c(252,330,403,414,436) |> as.integer()
# New Forest West is 330
nlistconst[[330]] <- c(122,252,329,339,414) |> as.integer()

# Isle of Wight is 252
nlistconst[[252]] <- c(188,202,329,330,384) |> as.integer()


# Arfon is 8
nlistconst[[8]] <- c(2,162,569) |> as.integer()
# Aberconwy is 2
nlistconst[[2]] <- c(8,129,162,569) |> as.integer()

# Ynys Mon is 569
nlistconst[[569]] <- c(2,8) |> as.integer()

# Humber estuary bridge. Cleethorpes (127) to Kingston Upon Hull West and Hessle (264)
nlistconst[[127]] <- c(74,196,206,264,290) |> as.integer()
nlistconst[[264]] <- c(127,214,262,263) |> as.integer()

# Poole (381) and South Dorset (440) are ferry connected
nlistconst[[381]] <- c(61,310,440) |> as.integer()
nlistconst[[440]] <- c(310,339,381,538) |> as.integer()

# Mersey crossings. Wallasey (517) and Birkenhead (34) to Liverpool Riverside (284)
nlistconst[[517]] <- c(34,284,551) |> as.integer()
nlistconst[[34]] <- c(284,517,550,551) |> as.integer()
nlistconst[[284]] <- c(34,57,197,285,286,517) |> as.integer()

# Dartford crossing. Dartford (146) and Thurrock (499)
nlistconst[[146]] <- c(33,205,368,420,499,501) |> as.integer()
nlistconst[[499]] <- c(144,146,241,437) |> as.integer()

# St Ives (470), connect it to 'Truro and Falmouth' (508), one constituency further back on peninsula
nlistconst[[470]] <- c(94,508) |> as.integer()
nlistconst[[508]] <- c(94,466,470) |> as.integer()

# it should be of class "nb" for `mgcv`
class(nlistconst) <- "nb"

```

This is the original model fitted using the `mgcv` package.

```{r, eval=FALSE}

mgcv_icar <- gam(con_swing ~
                   degree_educated +
                   health_not_good +
                   white +
                   s(region, bs="re") +
                   s(degree_educated,region, bs="re") +
                   s(health_not_good,region, bs="re") +
                   s(white,region, bs="re") +
                   s(county, bs="re") +
                   s(degree_educated,county, bs="re") +
                   s(health_not_good,county, bs="re") +
                   s(white,county, bs="re") +
                   s(constituency_name, bs='mrf', xt=list(nb=nlistconst), k=311),
                 data=df_scaled, method="REML")

```

Its ICAR component is mapped below: 

```{r, fig.width=4, fig.height=4, echo=FALSE}

# saveRDS(mgcv_icar,"mgcv_icar.rds")
mgcv_icar <- readRDS("mgcv_icar.rds")

# summary(mgcv_icar)

temp <- tibble(
  degree_educated=rep(1,nrow(df_scaled)),
  health_not_good=rep(1,nrow(df_scaled)),
  white=rep(1,nrow(df_scaled)),
  region=df$region,
  county=df_scaled$county,
  constituency_name=df_scaled$constituency_name)

# then predict from this model using type="terms"
mgcv_icar_df <- predict(mgcv_icar,newdata = temp,type = "terms", se.fit = TRUE) |> 
  as.data.frame() |> 
  cbind(df_scaled) |> 
  as.data.frame() |> 
  mutate(geometry = df$geometry) |> 
  st_as_sf()

ggplot() +
  geom_sf(data=speaker_sf, colour="black", fill="black") + 
  geom_sf(data=mgcv_icar_df,aes(fill=fit.s.constituency_name.), colour=NA) +
  # geom_sf(data=counties, fill=NA, linewidth=0.05, colour="gray50") +
  geom_sf(data=regions, fill=NA, colour="black") +
  scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,
                       limits=c(-2.5,3)) +
  labs(fill=TeX("ICAR ($\\hat{\\gamma}_{l|m})")) +
  coord_sf(datum=NA) +
  theme_bw() + 
  theme(legend.position = c(0.16, 0.8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size=8),
        legend.key.size = unit(0.4, "cm"),
        legend.background = element_rect(linewidth = 0.5, colour = 1),
        panel.background = element_rect(fill = "ivory2", color = "black"))

```

### Global standard deviation

#### brms using mgcv smooth icar

The specifications of the `mgcv` model can be reproduced in a Bayesian framework using `brms`. 

```{r, eval=FALSE}

brms_icar_mgcv <- brm(con_swing ~ 1 + degree_educated +
                    health_not_good +
                    white +
                    (1 + degree_educated + health_not_good + white || region/county) +
                    s(constituency_name, bs='mrf', xt=list(nb=nlistconst), k=311),
                  data=df_scaled, cores = 4, iter = 6000, thin = 4,
                  silent = TRUE)

```

```{r, echo=FALSE}

# saveRDS(brms_icar_mgcv,"brms_icar_mgcv.rds")
brms_icar_mgcv <- readRDS("brms_icar_mgcv.rds")
# stancode(brms_icar_mgcv)
# summary(brms_icar_mgcv)

p_brms_icar_mgcv <- posterior_summary(brms_icar_mgcv,probs = 0.5) |> 
  data.frame() |> 
  rownames_to_column(var="parameter")

```

The resulting ICAR structure based on the posterior means is extremely similar to that of the `mgcv` model:

```{r, fig.width=4, fig.height=4, echo=FALSE}

p_brms_icar_mgcv_mean <- posterior_smooths(brms_icar_mgcv,smooth = 's(constituency_name, bs="mrf", xt=list(nb=nlistconst), k=311)') |> 
  data.frame() |> 
  apply(2, mean)
df$p_brms_icar_mgcv_mean <- p_brms_icar_mgcv_mean

ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=p_brms_icar_mgcv_mean), colour=NA) + 
    geom_sf(data=regions, colour="black", fill=NA) + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,
                       limits=c(-2.5,3)) +
    labs(fill = "posterior\nmrf_mean") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(legend.position = c(0.16, 0.8),
          legend.title = element_text(size = 8),
          legend.text = element_text(size=5),
          legend.key.size = unit(0.4, "cm"),
          legend.background = element_rect(linewidth = 0.5, colour = 1),
          panel.background = element_rect(fill = "ivory2", color = "black"))

```

Some of the limitations of the `mgcv` model can be overcome in `brms`. In the model below, correlation has additionally been allowed between the random coefficients (by using | instead of ||). This is not possible with random effects in `mgcv`. Furthermore, this model is not subject to the restriction of max(k)=311 from `mgcv`. By not specifying any k, the full 571 x 571 covariance matrix is used.

```{r, eval=FALSE}

brms_icar2 <- brm(con_swing ~ 1 + degree_educated +
                    health_not_good +
                    white +
                    (1 + degree_educated + health_not_good + white | region/county) +
                    s(constituency_name, bs='mrf', xt=list(nb=nlistconst)),
                  data=df_scaled, data2=list(W=W), cores = 4, iter = 8000, thin = 4,
                  silent = TRUE)

```

```{r, echo=FALSE}

# saveRDS(brms_icar2,"brms_icar2.rds")
brms_icar2 <- readRDS("brms_icar2.rds")
# stancode(brms_icar2)
# summary(brms_icar2)

p_brms_icar2 <- posterior_summary(brms_icar2,probs = 0.5) |> 
  data.frame() |> 
  rownames_to_column(var="parameter")

```

```{r, fig.width=10, fig.height=6, eval=FALSE, echo=FALSE}

regions$degree_posterior_mean2 <- p_brms_icar2[str_detect(p_brms_icar2$parameter, "^r_region\\[.*degree"),]$Estimate
regions$health_posterior_mean2 <- p_brms_icar2[str_detect(p_brms_icar2$parameter, "^r_region\\[.*health"),]$Estimate
regions$white_posterior_mean2 <- p_brms_icar2[str_detect(p_brms_icar2$parameter, "^r_region\\[.*white"),]$Estimate

counties$degree_posterior_mean2 <- p_brms_icar2[str_detect(p_brms_icar2$parameter, "^r_region:county\\[.*degree"),]$Estimate
counties$health_posterior_mean2 <- p_brms_icar2[str_detect(p_brms_icar2$parameter, "^r_region:county\\[.*health"),]$Estimate
counties$white_posterior_mean2 <- p_brms_icar2[str_detect(p_brms_icar2$parameter, "^r_region:county\\[.*white"),]$Estimate

ggarrange(
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=degree_posterior_mean2), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-2,2.5)) +
    labs(fill = "posterior mean",
         title = "region random effects",
         subtitle = "degree_educated") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=health_posterior_mean2), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-2,2.5)) +
    labs(fill = "posterior mean",
         title = "region random effects",
         subtitle = "health_not_good") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=white_posterior_mean2), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-2,2.5)) +
    labs(fill = "posterior mean",
         title = "region random effects",
         subtitle = "white") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=degree_posterior_mean2), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-1.5,1.5)) +
    labs(fill = "posterior mean",
         title = "county random effects",
         subtitle = "degree_educated") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=health_posterior_mean2), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-1.5,1.5)) +
    labs(fill = "posterior mean",
         title = "county random effects",
         subtitle = "health_not_good") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=white_posterior_mean2), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-1.5,1.5)) +
    labs(fill = "posterior mean",
         title = "county random effects",
         subtitle = "white") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol=3,
  nrow=2,
  common.legend = TRUE,
  legend="right"
)

```

As is the case with greater values of k in an `mgcv` ICAR model using *bs = mrf*, this decreases the level of smoothness:

```{r, fig.width=4, fig.height=4, echo=FALSE}

p_brms_icar2s_mean <- posterior_smooths(brms_icar2,smooth = 's(constituency_name, bs="mrf", xt=list(nb=nlistconst))') |> 
  data.frame() |> 
  apply(2, mean)
p_brms_icar2s_median <- posterior_smooths(brms_icar2,smooth = 's(constituency_name, bs="mrf", xt=list(nb=nlistconst))') |> 
  data.frame() |> 
  apply(2, median)
df$p_brms_icar2s_mean <- p_brms_icar2s_mean
df$p_brms_icar2s_median <- p_brms_icar2s_median

ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=p_brms_icar2s_mean), colour=NA) + 
    geom_sf(data=regions, colour="black", fill=NA) + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,
                       limits=c(-2.5,3)) +
    labs(fill = "posterior\nmrf_mean") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(legend.position = c(0.16, 0.8),
          legend.title = element_text(size = 8),
          legend.text = element_text(size=5),
          legend.key.size = unit(0.4, "cm"),
          legend.background = element_rect(linewidth = 0.5, colour = 1),
          panel.background = element_rect(fill = "ivory2", color = "black"))

```

#### brms built-in icar

`brms` has the in-built capacity to set up different types of spatial conditional autoregressive terms. Currently implemented are "escar" (exact sparse CAR), "esicar" (exact sparse intrinsic CAR), "icar" (intrinsic CAR), and "bym2". The "escar" and "esicar" types are implemented based on the case study of Max Joseph (https://github.com/mbjoseph/CARstan). The "icar" and "bym2" type is implemented based on the case study of Mitzi Morris (https://mc-stan.org/users/documentation/case-studies/icar_stan.html).

```{r, echo=FALSE}

W <-nb2mat(nlistconst)

W[W!=0] <- 1
rownames(W)<-df$constituency_name

```

The following model makes use of the *type = "icar"* component:

```{r, eval=FALSE}

brms_icar <- brm(con_swing ~ 1 + degree_educated +
                   health_not_good +
                   white +
                   (1 + degree_educated + health_not_good + white || region/county) +
                   car(W, type = "icar", gr=constituency_name),
                 data=df_scaled, data2=list(W=W), cores = 4, iter = 6000, thin = 4,
                 silent = TRUE)

```

```{r, echo=FALSE}

# saveRDS(brms_icar,"brms_icar.rds")
brms_icar <- readRDS("brms_icar.rds")

# summary(brms_icar)

p_brms_icar <- posterior_summary(brms_icar,probs = 0.5) |> 
  data.frame() |> 
  rownames_to_column(var="parameter")

```

```{r, fig.width=10, fig.height=6, eval=FALSE, echo=FALSE}

regions$degree_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "^r_region\\[.*degree"),]$Estimate
regions$health_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "^r_region\\[.*health"),]$Estimate
regions$white_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "^r_region\\[.*white"),]$Estimate

counties$degree_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "^r_region:county\\[.*degree"),]$Estimate
counties$health_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "^r_region:county\\[.*health"),]$Estimate
counties$white_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "^r_region:county\\[.*white"),]$Estimate

ggarrange(
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=degree_posterior_mean), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-2,2.5)) +
    labs(fill = "posterior mean",
         title = "region random effects",
         subtitle = "degree_educated") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=health_posterior_mean), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-2,2.5)) +
    labs(fill = "posterior mean",
         title = "region random effects",
         subtitle = "health_not_good") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=white_posterior_mean), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-2,2.5)) +
    labs(fill = "posterior mean",
         title = "region random effects",
         subtitle = "white") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=degree_posterior_mean), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-1.5,1.5)) +
    labs(fill = "posterior mean",
         title = "county random effects",
         subtitle = "degree_educated") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=health_posterior_mean), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-1.5,1.5)) +
    labs(fill = "posterior mean",
         title = "county random effects",
         subtitle = "health_not_good") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=white_posterior_mean), colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, limits=c(-1.5,1.5)) +
    labs(fill = "posterior mean",
         title = "county random effects",
         subtitle = "white") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol=3, 
  nrow=2,
  common.legend = TRUE,
  legend="right"
)

```

The following map shows posterior means of this *type = "icar"* implementation. They are quite similar to those of `mgcv` but, again, less smooth.

```{r, fig.width=12, echo=FALSE}

df$mrf_posterior_median <- p_brms_icar[str_detect(p_brms_icar$parameter, "rcar"),]$Q50
df$mrf_posterior_mean <- p_brms_icar[str_detect(p_brms_icar$parameter, "rcar"),]$Estimate

sdcar_post_original <- p_brms_icar[str_detect(p_brms_icar$parameter, "sdcar"),]$Estimate |> 
  round(2)
df$sdcar_post_original <- sdcar_post_original
ggarrange(
ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=mrf_posterior_mean), colour=NA) + 
    geom_sf(data=regions, colour="black", fill=NA) + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0) +
    labs(fill = "posterior\nmrf_mean",
         title = "ICAR: global sd") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=sdcar_post_original), colour="black") + 
    geom_sf_label(data=regions,
                      aes(label=round(sdcar_post_original,2), fill=sdcar_post_original, !!!autocontrast), size=4) +
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title="global sd") + 
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol=2
)

```

### Standard deviation by region

#### stan from brms with adaptations

By using the `brms` function *stancode()* to produce the `stan` code for the above model, changes can be made to the `stan` code to allow for a different standard deviation for each region. This code is shown below with the alterations marked as commented lines.

```{r, eval=FALSE}

## stan code
// generated with brms 2.19.0
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  // data for the CAR structure
  int<lower=1> Nloc;
  int<lower=1> Jloc[N];
  int<lower=0> Nedges;
  int<lower=1> edges1[Nedges];
  int<lower=1> edges2[Nedges];
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  int<lower=1> J_1[N];  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  vector[N] Z_1_2;
  vector[N] Z_1_3;
  vector[N] Z_1_4;
  // data for group-level effects of ID 2
  int<lower=1> N_2;  // number of grouping levels
  int<lower=1> M_2;  // number of coefficients per level
  int<lower=1> J_2[N];  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_2_1;
  vector[N] Z_2_2;
  vector[N] Z_2_3;
  vector[N] Z_2_4;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  int Kc = K - 1;
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // population-level effects
  real Intercept;  // temporary intercept for centered predictors
##### alterations made here #################################################
  vector<lower=0> [N_1] sdcar;  // SD of the CAR structure
#############################################################################
  // parameters for the ICAR structure
  vector[N] zcar;
  real<lower=0> sigma;  // dispersion parameter
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  vector[N_1] z_1[M_1];  // standardized group-level effects
  vector<lower=0>[M_2] sd_2;  // group-level standard deviations
  vector[N_2] z_2[M_2];  // standardized group-level effects
}
transformed parameters {
  // scaled parameters for the ICAR structure
  vector[N] rcar;
  vector[N_1] r_1_1;  // actual group-level effects
  vector[N_1] r_1_2;  // actual group-level effects
  vector[N_1] r_1_3;  // actual group-level effects
  vector[N_1] r_1_4;  // actual group-level effects
  vector[N_2] r_2_1;  // actual group-level effects
  vector[N_2] r_2_2;  // actual group-level effects
  vector[N_2] r_2_3;  // actual group-level effects
  vector[N_2] r_2_4;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
##### alterations made here #################################################
  // compute scaled parameters for the ICAR structure
  for (n in 1:N) {
    rcar[n] = zcar[n] .* sdcar[J_1[n]];
  }
#############################################################################
  r_1_1 = (sd_1[1] * (z_1[1]));
  r_1_2 = (sd_1[2] * (z_1[2]));
  r_1_3 = (sd_1[3] * (z_1[3]));
  r_1_4 = (sd_1[4] * (z_1[4]));
  r_2_1 = (sd_2[1] * (z_2[1]));
  r_2_2 = (sd_2[2] * (z_2[2]));
  r_2_3 = (sd_2[3] * (z_2[3]));
  r_2_4 = (sd_2[4] * (z_2[4]));
  lprior += student_t_lpdf(Intercept | 3, 4.7, 3.1);
  lprior += student_t_lpdf(sdcar | 3, 0, 3.1)
    - 1 * student_t_lccdf(0 | 3, 0, 3.1);
  lprior += student_t_lpdf(sigma | 3, 0, 3.1)
    - 1 * student_t_lccdf(0 | 3, 0, 3.1);
  lprior += student_t_lpdf(sd_1 | 3, 0, 3.1)
    - 4 * student_t_lccdf(0 | 3, 0, 3.1);
  lprior += student_t_lpdf(sd_2 | 3, 0, 3.1)
    - 4 * student_t_lccdf(0 | 3, 0, 3.1);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Intercept + Xc * b;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += rcar[n] + r_1_1[J_1[n]] * Z_1_1[n] + r_1_2[J_1[n]] * Z_1_2[n] + r_1_3[J_1[n]] * Z_1_3[n] + r_1_4[J_1[n]] * Z_1_4[n] + r_2_1[J_2[n]] * Z_2_1[n] + r_2_2[J_2[n]] * Z_2_2[n] + r_2_3[J_2[n]] * Z_2_3[n] + r_2_4[J_2[n]] * Z_2_4[n];
    }
    target += normal_lpdf(Y | mu, sigma);
  }
  // priors including constants
  target += lprior;
  // improper prior on the spatial CAR component
  target += -0.5 * dot_self(zcar[edges1] - zcar[edges2]);
  // soft sum-to-zero constraint
  target += normal_lpdf(sum(zcar) | 0, 0.001 * Nloc);
  target += std_normal_lpdf(z_1[1]);
  target += std_normal_lpdf(z_1[2]);
  target += std_normal_lpdf(z_1[3]);
  target += std_normal_lpdf(z_1[4]);
  target += std_normal_lpdf(z_2[1]);
  target += std_normal_lpdf(z_2[2]);
  target += std_normal_lpdf(z_2[3]);
  target += std_normal_lpdf(z_2[4]);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
  
  // Log likelihood for observed data
  vector[N] log_lik;
  for (n in 1:N) {
    log_lik[n] = normal_lpdf(Y[n] | b_Intercept + Xc[n] * b + rcar[n] +
                                      r_1_1[J_1[n]] * Z_1_1[n] +
                                      r_1_2[J_1[n]] * Z_1_2[n] +
                                      r_1_3[J_1[n]] * Z_1_3[n] +
                                      r_1_4[J_1[n]] * Z_1_4[n] +
                                      r_2_1[J_2[n]] * Z_2_1[n] +
                                      r_2_2[J_2[n]] * Z_2_2[n] +
                                      r_2_3[J_2[n]] * Z_2_3[n] +
                                      r_2_4[J_2[n]] * Z_2_4[n],
                                      sigma);
  }
}

```

The results (mapped below) suggest that constituencies in red regions (Wales, the South West, the South East, the North West, and the East) have lower standard deviations and are more likely to behave in similar ways to their neighbours than is suggested by the global standard deviation model. On the other hand, constituencies in blue regions (London, Merseyside, the East Midlands, the West Midlands, Yorkshire & The Humber, and the North East) are likely to behave in less similar ways to their neighbours than the other model suggests.

```{r, echo=FALSE}

stan_brms_icar_varysd_data <- prep_icar_data(nb2mat(nlistconst))

# make population-level design matrix
X = data.frame(rep(1,nrow(df_scaled)),
               df_scaled$degree_educated,
               df_scaled$health_not_good,
               df_scaled$white) |> 
  as.matrix()

# region
# make data list as required to feed to stan
stan_brms_icar_varysd_data_list <- list(
  N = nrow(df_scaled),
  Y = df_scaled$con_swing,
  K = 4,
  X = X,
  Nloc = nrow(df_scaled),
  Jloc = seq(1:nrow(df_scaled)),
  Nedges = stan_brms_icar_varysd_data$n_edges,
  edges1 = stan_brms_icar_varysd_data$node1,
  edges2 = stan_brms_icar_varysd_data$node2,
  N_1 = length(unique(df_scaled$region)),
  M_1 = 4,
  J_1 = as.numeric(df_scaled$region),
  Z_1_1 = rep(1,nrow(df_scaled)),
  Z_1_2 = df_scaled$degree_educated,
  Z_1_3 = df_scaled$health_not_good,
  Z_1_4 = df_scaled$white,
  NC_1 = 6,
  N_2 = length(unique(df_scaled$county)),
  M_2 = 4,
  J_2 = as.numeric(df_scaled$county),
  Z_2_1 = rep(1,nrow(df_scaled)),
  Z_2_2 = df_scaled$degree_educated,
  Z_2_3 = df_scaled$health_not_good,
  Z_2_4 = df_scaled$white,
  NC_2 = 6,
  prior_only = 0)

# mod_varysd <- stan('stan_brms_icar_varysd.stan',iter=20000, data=stan_brms_icar_varysd_data_list, 
#                                      cores = 4, thin = 5)
# 
# saveRDS(mod_varysd,"mod_varysd.rds")
mod_varysd <- readRDS("mod_varysd.rds")

# summary(mod_varysd)

```

```{r, fig.width=12, echo=FALSE}

sdcar_post <- as.matrix(mod_varysd,pars='sdcar') |> 
  apply(2,mean)
regions$sdcar_post <- sdcar_post

mrf_post <- as.matrix(mod_varysd,pars='rcar')
df$mrf_post <- apply(mrf_post,2,mean)

ggarrange(
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=mrf_post), colour=NA) +
    geom_sf(data=regions, fill=NA, colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,  
                         limits=c(-4.699408, 8.857563)) +
    labs(fill = "posterior\nmrf_mean",
         title = "ICAR: sd by region") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=sdcar_post), colour="black") + 
    geom_sf_label(data=regions,
                      aes(label=round(sdcar_post,2), fill=sdcar_post, !!!autocontrast), size=4) +
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "sd by region") + 
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol=2
)

```

Ranking of regions within which neighbouring constituencies resemble each other in swing behaviour from least similar (East Midlands) to most (South West):

```{r, echo=FALSE}

regions |> select(region,sdcar_post) |> 
  mutate(sdcar_post=round(sdcar_post,2),) |>
  mutate(relative_to_global_sd = round(sdcar_post/sdcar_post_original,2)) |> 
  rename(sd_by_region = sdcar_post) |> 
  st_drop_geometry() |> 
  arrange(desc(sdcar_post))

```

### Standard deviation by county

#### stan from brms with adaptations

The same can be done, by altering the indexing of the `stan` code appropriately, to allow for a different standard deviation for each county.

```{r, echo=FALSE}

# mod_varysd2 <- stan('stan_brms_icar_varysd2.stan',iter=20000, data=stan_brms_icar_varysd_data_list, 
#                                      cores = 4, thin = 5)
# 
# saveRDS(mod_varysd2,"mod_varysd2.rds")
mod_varysd2 <- readRDS("mod_varysd2.rds")

# summary(mod_varysd2)

```


```{r, fig.width=12, echo=FALSE}

sdcar_post2 <- as.matrix(mod_varysd2,pars='sdcar') |> 
  apply(2,mean)
counties$sdcar_post2 <- sdcar_post2

mrf_post2 <- as.matrix(mod_varysd2,pars='rcar')
df$mrf_post2 <- apply(mrf_post2,2,mean)

ggarrange(
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=mrf_post2), colour=NA) +
    geom_sf(data=regions, fill=NA, colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,  
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "ICAR: sd by county") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=sdcar_post2), colour="gray70") + 
    geom_sf(data=regions, colour="black", fill=NA, linewidth=0.5) + 
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "sd by county") + 
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol=2
)

```

The 10 counties within which neighbouring constituencies least resemble each other in swing behaviour:

```{r, echo=FALSE}

counties |> 
  select(county,sdcar_post2) |> 
  mutate(sdcar_post2=round(sdcar_post2,2),) |>
  mutate(relative_to_global_sd = round(sdcar_post2/sdcar_post_original,2)) |> 
  rename(sd_by_county = sdcar_post2) |> 
  st_drop_geometry() |> 
  arrange(desc(sdcar_post2)) |> 
  head(10) |> 
  left_join(df |> st_drop_geometry() |> group_by(county) |> select(county,region) |> unique()) |> 
  select(county,region,sd_by_county,relative_to_global_sd)

```

The 10 counties within which neighbouring constituencies most resemble each other in swing behaviour:

```{r, echo=FALSE}

counties |> 
  select(county,sdcar_post2) |> 
  mutate(sdcar_post2=round(sdcar_post2,2),) |>
  mutate(relative_to_global_sd = round(sdcar_post2/sdcar_post_original,2)) |> 
  rename(sd_by_county = sdcar_post2) |> 
  st_drop_geometry() |> 
  arrange(desc(sdcar_post2)) |> 
  tail(10) |> 
  left_join(df |> st_drop_geometry() |> group_by(county) |> select(county,region) |> unique()) |> 
  select(county,region,sd_by_county,relative_to_global_sd)
```

Enlarged below are the mean posterior standard deviation values for each county in this ICAR structure:

```{r, fig.width=8, fig.height=8, echo=FALSE}

ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=sdcar_post2), colour="black") + 
    geom_sf_label(data=counties,
                      aes(label=round(sdcar_post2,2), fill=sdcar_post2, !!!autocontrast), size=3, fontface="bold") +
    geom_sf(data=regions, colour="black", fill=NA, linewidth=0.5) + 
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "sd by county") + 
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black"))


```

```{r, echo=FALSE}

# how many constituencies in each county. is this relevant?

# library(classInt)
# df_county_count <- df |> 
#   group_by(county) |> 
#   summarise(count = n())
# 
# countjenks <- classIntervals(var=df_county_count$count,
#                                              n=9,
#                                              style="jenks")
# breaks <- countjenks$brks
# df_county_count$countjenks <- factor(cut(df_county_count$count, breaks, include.lowest = TRUE, labels = FALSE))



# ggplot() + 
#     geom_sf(data=speaker_sf, colour="black", fill="black") + 
#     geom_sf(data=df_county_count, aes(fill=countjenks), colour="black") + 
#     geom_sf_label(data=df_county_count,
#                       aes(label=count, fill=countjenks, !!!autocontrast), size=3, fontface="bold") +
#     geom_sf(data=regions, colour="black", fill=NA, linewidth=0.5) + 
#   scale_fill_brewer(palette = "OrRd") + 
#     # scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = median(df_county_count$count)) + 
#     labs(title="constituency count") + 
#   guides(fill="none") + 
#     coord_sf(datum=NA) +
#     theme_bw() +
#     theme(axis.title = element_blank(),
#           panel.background = element_rect(fill = "ivory2", color = "black"))
# 
# cor(counties$sdcar_post2,df_county_count$count)

```

### Comparison of models

#### as projected maps

Below, the ICAR structures of these three models and their standard deviations are presented side by side.

```{r, fig.width=12, fig.height=5, echo=FALSE}

ggarrange(
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=mrf_posterior_mean), colour=NA) + 
    geom_sf(data=regions, colour="black", fill=NA) + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,  
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "ICAR constituency",
         subtitle = "global sd") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=mrf_post), colour=NA) +
    geom_sf(data=regions, fill=NA, colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,  
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "",
         subtitle = "sd by region") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df, aes(fill=mrf_post2), colour=NA) +
    geom_sf(data=regions, fill=NA, colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0,  
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "", 
         subtitle = "sd by county") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol = 3,
  legend = "right",
  common.legend = TRUE
)

```

```{r, fig.width=12, fig.height=5, echo=FALSE}

ggarrange(
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=sdcar_post_original), colour="black") + 
    geom_sf_label(data=regions,
                      aes(label=round(sdcar_post_original,2), fill=sdcar_post_original, !!!autocontrast), size=2.5) +
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "standard deviations", 
         subtitle = "global sd") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
 
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=regions, aes(fill=sdcar_post), colour="black") + 
    geom_sf_label(data=regions,
                      aes(label=round(sdcar_post,2), fill=sdcar_post, !!!autocontrast), size=2.5) +
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "", 
         subtitle = "sd by region") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=counties, aes(fill=sdcar_post2), colour="gray90") + 
    geom_sf(data=regions, colour="black", fill=NA) + 
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "", 
         subtitle = "sd by county") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol = 3,
  legend = "right",
  common.legend = TRUE
)

```

#### as cartograms

This format, where each pixel represents an equal population, gives improved visibility of all of the constituencies

```{r, fig.width=12, fig.height=5, echo=FALSE}

df_carto <- df |> 
  mutate(geometry=const_contig$geometry)

df_carto_r <- regions |> 
  mutate(geometry=carto_region$geometry)

df_carto_c <- counties |> 
  mutate(geometry=carto_county$geometry)

ggarrange(
  ggplot() + 
    # geom_sf(data=df_carto_speaker, colour="black", fill="black") +
    geom_sf(data=df_carto, aes(fill=mrf_posterior_mean), colour=NA) + 
    geom_sf(data=carto_region, colour="black", fill=NA) + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, 
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "ICAR constituency",
         subtitle = "constant sd") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    # geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df_carto, aes(fill=mrf_post), colour=NA) +
    geom_sf(data=carto_region, fill=NA, colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, 
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "",
         subtitle = "sd by region") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    # geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df_carto, aes(fill=mrf_post2), colour=NA) +
    geom_sf(data=carto_region, fill=NA, colour="black") + 
    scale_fill_gradient2(low="darkred",mid="white",high="#073763",midpoint = 0, 
                         limits=c(min(df$mrf_post2),max(df$mrf_post2))) +
    labs(fill = "posterior\nmrf_mean",
         title = "",
         subtitle = "sd by county") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol = 3,
  legend = "right",
  common.legend = TRUE
)

```

```{r, fig.width=12, fig.height=5, echo=FALSE}

ggarrange(
  ggplot() + 
    # geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df_carto_r, aes(fill=sdcar_post_original), colour="black") + 
    geom_sf_label(data=df_carto_r,
                      aes(label=round(sdcar_post_original,2), fill=sdcar_post_original, !!!autocontrast), size=2.5) +
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "standard deviations",
         subtitle = "constant sd") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
 
  ggplot() + 
    # geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df_carto_r, aes(fill=sdcar_post), colour="black") + 
    geom_sf_label(data=df_carto_r,
                      aes(label=round(sdcar_post,2), fill=sdcar_post, !!!autocontrast), size=2.5) +
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "",
         subtitle = "sd by region") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ggplot() + 
    # geom_sf(data=speaker_sf, colour="black", fill="black") + 
    geom_sf(data=df_carto_c, aes(fill=sdcar_post2), colour="gray90") + 
    geom_sf(data=df_carto_r, colour="black", fill=NA) + 
    scale_fill_gradient2(low="tomato",mid="white",high="steelblue1",midpoint = sdcar_post_original, limits=c(0,7)) + 
    labs(fill="posterior\nstd dev\nmean",
         title = "",
         subtitle = "sd by county") +
    coord_sf(datum=NA) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.background = element_rect(fill = "ivory2", color = "black")),
  
  ncol=3,
  legend = "right",
  common.legend = TRUE
)

```

#### WAIC

The model with varying standard deviation by county has the best WAIC, followed by the global model using the `brms` "icar" component, then the model which varies by region. These three `brms` models which do not feature `mgcv`-style components perform better than the bottom two which are based on `mgcv`.

```{r, echo=FALSE}

waic0 <- brms::waic(brms_icar)
waic0 <- waic0$waic

# brms mgcv 311
waic3 <- brms::waic(brms_icar_mgcv)
waic3 <- waic3$waic

# brms mgcv 571 (full)
waic4 <- brms::waic(brms_icar2)
waic4 <- waic4$waic

# waic(mod_varysd)
# waic(mod_varysd2)
waic1 <- loo::waic(extract(mod_varysd)$log_lik)
waic1 <- waic1$waic
waic2 <- loo::waic(extract(mod_varysd2)$log_lik)
waic2 <- waic2$waic
# loo1 <- loo(mod_varysd)
# loo2 <- loo(mod_varysd2)
# 
# print(loo1)
# print(loo2)
# 
# plot(loo1,label_points=TRUE)
# plot(loo2,label_points=TRUE)
# 
# loo_compare(loo1,loo2)

waic_df <- data.frame(
  model = c("brms with brms icar","brms with brms icar (with modified stan)","brms with brms icar (with modified stan)","brms with mgcv icar (k=311)","brms with mgcv icar (k=571)"),
  `std.dev.scale`= c("global","region","county","global","global"),
  WAIC = round(c(waic0,waic1,waic2,waic3,waic4),1)) |> 
  arrange(WAIC)
waic_df$relativeWIAC <- round(waic_df$WAIC/min(waic_df$WAIC),5)

waic_df

```


